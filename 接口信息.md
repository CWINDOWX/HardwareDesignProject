# 接口信息

### 1.alu.v

```verilog
module alu(
	input wire[31:0] a,b,
	input wire[2:0] op,
	input wire hassign, //判断是不是有符号的计算
	output reg[31:0] y,
	output reg[31:0] y_lo, //做乘除法时需要用到，结果的低32位
	output reg overflow,
	output wire zero
    );
```

--***1.22***

  alu新增了一个**hassign信号**，意义在于**告诉alu这次运算是有符号运算**，**还是无符号运算**。hassign的传递路径和alu_control信号一致，由controller (maindec+aludec合并）产生，此时为hassignD，经过流水线传递到hassignE，最后将hassignE传递给alu。明确标记了是有符号运算的指令，他们的hassign应该被标记为1，其中miandec和aludec都有权标记hassign信号的值，最后的结果应当是两个值进行或运算。

  有符号运算不一定代表了一定会触发溢出异常，算术指令里，只有ADD和SUB会触发异常，所以alu里只有这两个指令会计算异常。**对于是否产生需要处理的溢出异常，应该使用hassign & overflow进行判断**。

  alu_control信号和对应的计算如下：

- 000->AND
- 001->OR
- 010->ADD
- 011->暂无功能
- 100->MULT（由hassign区分有无符号）
- 101->暂无功能
- 110->SUB
- 111->SLT （由hassign区分有无符号）

 ***--1.24***

  alu新增y_lo，表示乘除法输出的低位

---

### 2.controller.v

```verilog
module controller(
	input wire clk,rst,
	//decode stage
	input wire[5:0] opD,functD,
	output wire pcsrcD,branchD,equalD,jumpD,
	
	//execute stage
	input wire flushE,
	output wire memtoregE,alusrcE,
	output wire regdstE,regwriteE,	
	output wire[2:0] alucontrolE,
	output wire hassignE,    // 判断是不是有符号的计算
	output wire [1:0] hilo_enE,
	output wire [1:0] hilo_mfE,
	output wire divE,

	//mem stage
	output wire memtoregM,memwriteM,
				regwriteM,
	//write back stage
	output wire memtoregW,regwriteW

    );
```

1. 新增了hassign信号，需要把它传递给datapath里的alu。hassign是由maindec和aludec共同产生的。
2. 新增hilo_en信号和hilo_mf信号，一个对应hilo寄存器的写使能，一个对应MF指令，即从HILO寄存器写回到寄存器堆的两个指令。
3. 新增div信号，表示该指令是否是一个除法指令

---

### 3.maindec.v

```verilog
module maindec(
	input wire[5:0] op,

	output wire memtoreg,memwrite,
	output wire branch,alusrc,
	output wire regdst,regwrite,
	output wire jump,
	output wire[1:0] aluop,
	output wire hassign
    );
```

1. 新增hassign信号

---

### 4.aludec.v

```verilog
module aludec(
	input wire[5:0] funct,
	input wire[1:0] aluop,
	output reg[2:0] alucontrol,
	output reg hassign,
    output reg[1:0] hilo_en,
    output reg[1:0] hilo_mf,
    output reg div
    );
```

1. 新增hassign信号。
2. 新增hilo_en和hilo_mf信号。信号含义见controller。
3. 新增div信号。表示该指令是否是一个除法指令。

---

### 5.datapath.v

```verilog
module datapath(
	input wire clk,rst,
	//fetch stage
	output wire[31:0] pcF,
	input wire[31:0] instrF,
	//decode stage
	input wire pcsrcD,branchD,
	input wire jumpD,
	output wire equalD,
	output wire[5:0] opD,functD,
	//execute stage
	input wire memtoregE,
	input wire alusrcE,regdstE,
	input wire regwriteE,
	input wire[2:0] alucontrolE,
	input wire hassignE,    // 判断是不是有符号的计算
	input wire [1:0] hilo_enE,
	input wire [1:0] hilo_mfE,
	input wire divE,
	output wire flushE,
	//mem stage
	input wire memtoregM,
	input wire regwriteM,
	output wire[31:0] aluoutM,writedataM,
	input wire[31:0] readdataM,
	//writeback stage
	input wire memtoregW,
	input wire regwriteW
    );
```

1. 新增hassignE信号，由controller传递过来，再交给alu。
2. 新增hilo_en和hilo_mf信号，信号含义见controller。需要注意的是，datapath里alu的输出结果变成了aluresult，需要经过选择器才会把输出结果变成aluout，这主要是为了实现MF指令自动在WB阶段写回寄存器堆的功能。
3. 新增divE信号，由controller传递，表示一个指令是否是除法指令。

---

### 6.hilo_reg.v

```verilog
module hilo_reg(
    input wire clk,rst,wediv,
    input wire [1:0] we,
    input wire [31:0] hi_in,
    input wire [31:0] lo_in,
    output reg [31:0] hi_out,
    output reg [31:0] lo_out
    );
```

  hi、lo寄存器堆。存储乘除法运算的高位和低位结果，同时也可以从这里把数据写回到寄存器堆。

  新增wediv指令，用于表示是否是除法指令的写使能。因为除法器需要32个周期进行运算，只有完成了最后一个周期之后，才能写进hi_lo寄存器里。

---

### 7.divider.v

```cpp
module divider(
    input clk,rst,en,hassign,
    input wire [31:0] a,    //被除数
    input wire [31:0] b,    //除数
    output reg [31:0] q,    //商
    output reg [31:0] r,    //余数
    output reg busy,done   //结束和忙碌
    );
```

  除法器，采用移位相减法，需要32个周期进行运算。

### 8.hazard.v

```cpp
module hazard(
	//fetch stage
	output wire stallF,
	//decode stage
	input wire[4:0] rsD,rtD,
	input wire branchD,
	output wire forwardaD,forwardbD,
	output wire stallD,
	//execute stage
	input wire[4:0] rsE,rtE,
	input wire[4:0] writeregE,
	input wire regwriteE,
	input wire memtoregE,
	input wire divE,
	input wire divbusyE,
	output reg[1:0] forwardaE,forwardbE,
	output wire flushE,
	//mem stage
	input wire[4:0] writeregM,
	input wire regwriteM,
	input wire memtoregM,

	//write back stage
	input wire[4:0] writeregW,
	input wire regwriteW
    );
```

  新增divE和divbusyE。这两个信号用于产生除法指令的阻塞信号。
