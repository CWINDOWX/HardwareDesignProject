# 接口信息

### 1.alu.v

```verilog
module alu(
	input wire[31:0] a,b,
	input wire[2:0] op,
	input wire hassign, //判断是不是有符号的计算
	output reg[31:0] y,
	output reg[31:0] y_lo, //做乘除法时需要用到，结果的低32位
	output reg overflow,
	output wire zero
    );
```

--**_1.22_**

alu 新增了一个**hassign 信号**，意义在于**告诉 alu 这次运算是有符号运算**，**还是无符号运算**。hassign 的传递路径和 alu_control 信号一致，由 controller (maindec+aludec 合并）产生，此时为 hassignD，经过流水线传递到 hassignE，最后将 hassignE 传递给 alu。明确标记了是有符号运算的指令，他们的 hassign 应该被标记为 1，其中 miandec 和 aludec 都有权标记 hassign 信号的值，最后的结果应当是两个值进行或运算。

有符号运算不一定代表了一定会触发溢出异常，算术指令里，只有 ADD 和 SUB 会触发异常，所以 alu 里只有这两个指令会计算异常。**对于是否产生需要处理的溢出异常，应该使用 hassign & overflow 进行判断**。

alu_control 信号和对应的计算如下：

逻辑运算（I 指令零扩展）：

- 001->OR
- 011->AND
- 101->NOR
- 111->XOR

算术运算（I 指令符号扩展）

- 000->SLT （由 hassign 区分有无符号）
- 010->ADD
- 100->MULT（由 hassign 区分有无符号）
- 110->SUB

  **_--1.24_**

  alu 新增 y_lo，表示乘除法输出的低位

---

### 2.controller.v

```verilog
module controller(
	input wire clk,rst,
	//decode stage
	input wire[5:0] opD,functD,
	output wire pcsrcD,branchD,equalD,jumpD,

	//execute stage
	input wire flushE,
	output wire memtoregE,alusrcE,
	output wire regdstE,regwriteE,
	output wire[2:0] alucontrolE,
	output wire hassignE,    // 判断是不是有符号的计算
	output wire [1:0] hilo_enE,
	output wire [1:0] hilo_mfE,
	output wire divE,

	//mem stage
	output wire memtoregM,memwriteM,
				regwriteM,
	//write back stage
	output wire memtoregW,regwriteW

    );
```

1. 新增了 hassign 信号，需要把它传递给 datapath 里的 alu。hassign 是由 maindec 和 aludec 共同产生的。
2. 新增 hilo_en 信号和 hilo_mf 信号，一个对应 hilo 寄存器的写使能，一个对应 MF 指令，即从 HILO 寄存器写回到寄存器堆的两个指令。
3. 新增 div 信号，表示该指令是否是一个除法指令

---

### 3.maindec.v

```verilog
module maindec(
	input wire[5:0] op,

	output wire memtoreg,memwrite,
	output wire branch,alusrc,
	output wire regdst,regwrite,
	output wire jump,
	output wire[1:0] aluop,
	output wire hassign
    );
```

1. 新增 hassign 信号

---

### 4.aludec.v

```verilog
module aludec(
	input wire[5:0] funct,
	input wire[1:0] aluop,
	output reg[2:0] alucontrol,
	output reg hassign,
    output reg[1:0] hilo_en,
    output reg[1:0] hilo_mf,
    output reg div
    );
```

1. 新增 hassign 信号。
2. 新增 hilo_en 和 hilo_mf 信号。信号含义见 controller。
3. 新增 div 信号。表示该指令是否是一个除法指令。

---

### 5.datapath.v

```verilog
module datapath(
	input wire clk,rst,
	//fetch stage
	output wire[31:0] pcF,
	input wire[31:0] instrF,
	//decode stage
	input wire pcsrcD,branchD,
	input wire jumpD,
	output wire equalD,
	output wire[5:0] opD,functD,
	//execute stage
	input wire memtoregE,
	input wire alusrcE,regdstE,
	input wire regwriteE,
	input wire[2:0] alucontrolE,
	input wire hassignE,    // 判断是不是有符号的计算
	input wire [1:0] hilo_enE,
	input wire [1:0] hilo_mfE,
	input wire divE,
	output wire flushE,
	//mem stage
	input wire memtoregM,
	input wire regwriteM,
	output wire[31:0] aluoutM,writedataM,
	input wire[31:0] readdataM,
	//writeback stage
	input wire memtoregW,
	input wire regwriteW
    );
```

1. 新增 hassignE 信号，由 controller 传递过来，再交给 alu。
2. 新增 hilo_en 和 hilo_mf 信号，信号含义见 controller。需要注意的是，datapath 里 alu 的输出结果变成了 aluresult，需要经过选择器才会把输出结果变成 aluout，这主要是为了实现 MF 指令自动在 WB 阶段写回寄存器堆的功能。
3. 新增 divE 信号，由 controller 传递，表示一个指令是否是除法指令。

---

### 6.hilo_reg.v

```verilog
module hilo_reg(
    input wire clk,rst,wediv,
    input wire [1:0] we,
    input wire [31:0] hi_in,
    input wire [31:0] lo_in,
    output reg [31:0] hi_out,
    output reg [31:0] lo_out
    );
```

hi、lo 寄存器堆。存储乘除法运算的高位和低位结果，同时也可以从这里把数据写回到寄存器堆。

新增 wediv 指令，用于表示是否是除法指令的写使能。因为除法器需要 32 个周期进行运算，只有完成了最后一个周期之后，才能写进 hi_lo 寄存器里。

---

### 7.divider.v

```cpp
module divider(
    input clk,rst,en,hassign,
    input wire [31:0] a,    //被除数
    input wire [31:0] b,    //除数
    output reg [31:0] q,    //商
    output reg [31:0] r,    //余数
    output reg busy,done,overflow   //结束和忙碌、除零溢出
    );
```

除法器，采用移位相减法，需要 32 个周期进行运算。overflow 表示是否产生了除零。

除法器进行了优化，但 hazard 单元会因为 divE 至少阻塞一个周期，所以对于那些一个周期就可以运算完的操作，仍需要一个额外的周期。

### 8.hazard.v

```cpp
module hazard(
	//fetch stage
	output wire stallF,
	//decode stage
	input wire[4:0] rsD,rtD,
	input wire branchD,
	output wire forwardaD,forwardbD,
	output wire stallD,
	//execute stage
	input wire[4:0] rsE,rtE,
	input wire[4:0] writeregE,
	input wire regwriteE,
	input wire memtoregE,
	input wire divE,
	input wire divbusyE,
	output reg[1:0] forwardaE,forwardbE,
	output wire flushE,
	//mem stage
	input wire[4:0] writeregM,
	input wire regwriteM,
	input wire memtoregM,

	//write back stage
	input wire[4:0] writeregW,
	input wire regwriteW
    );
```

新增 divE 和 divbusyE。这两个信号用于产生除法指令的阻塞信号。
